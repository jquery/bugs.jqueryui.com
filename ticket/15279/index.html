<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-pagefind-meta="title">#15279 (Support for private fields and methods within widgets) - jQuery UI - Bug Tracker</title>
    <meta name="description" content="Static archive of the old bugs.jqueryui.com Trac site.">
    
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/svg+xml" href="/favicon.svg">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
    
    
    
    
    
    
    
    
    <link rel="stylesheet" href="/bundle/u10aUuj4Q4.css">
  </head>
  <body>
    <div class="banner flex-center">
      <span>jQuery UI issues have moved to <a href="https://github.com/jquery/jquery-ui/issues">GitHub</a>. This site is now a static archive of the old <a href="https://trac.edgewall.org/">Trac</a> bugs site. <br>Some functions and pages are no longer available.</span>
    </div>
    <div class="container">
      <a href="#skip" class="visually-hidden">Skip to main content</a>
      <header class="flex-column">
        <div class="flex-row flex-between-start">
          <a id="jq-siteLogo" href="/" title="jQuery UI Bugs Home">
            <img src="/img/logo.svg" width="253" alt="jQuery UI">
          </a>
          <input class="hamburger-toggle visually-hidden" id="jq-menutoggle" type="checkbox">
          <label aria-label="Toggle Menu" for="jq-menutoggle" class="hamburger-lines flex-column flex-between-center">
            <span class="hamburger-line"></span>
            <span class="hamburger-line"></span>
            <span class="hamburger-line"></span>
          </label>
          <div id="jq-menus" class="flex-column">
            <nav id="jq-primaryNavigation">
              <h2 class="visually-hidden">jQuery UI sites navigation menu</h2>
              <ul class="nav">
                <li class="jq-jquery">
                  <a href="https://jquery.com/" title="jQuery Home">jQuery</a>
                </li>
                <li class="jq-plugins">
                  <a href="https://plugins.jquery.com/" title="jQuery Plugins">Plugins</a>
                </li>
                <li class="jq-ui active">
                  <a href="https://jqueryui.com/" title="jQuery UI">UI</a>
                </li>
                <li class="jq-meetup">
                  <a href="https://meetups.jquery.com/" title="jQuery Meetups">Meetups</a>
                </li>
                <li class="jq-forum">
                  <a href="https://forum.jquery.com/" title="jQuery Forum">Forum</a>
                </li>
                <li class="jq-blog">
                  <a href="https://blog.jquery.com/" title="jQuery Blog">Blog</a>
                </li>
                <li class="jq-about">
                  <a href="https://openjsf.org" title="About jQuery and OpenJS">About</a>
                </li>
                <li class="jq-donate">
                  <a href="https://openjsf.org/about/project-funding-opportunities/" title="Donate to OpenJS">Donate</a>
                </li>
              </ul>
            </nav>
            <nav id="jq-secondaryNavigation">
              <h2 class="visually-hidden">jQuery UI navigation menu</h2>
              <ul class="nav">
                <li class="jq-download">
                  <a href="https://jqueryui.com/download/">
                    Download
                  </a>
                </li>
                <li class="jq-documentation">
                  <a href="https://jqueryui.com/demos/">
                    Demos &amp; Documentation
                  </a>
                </li>
                <li class="jq-themes">
                  <a href="https://jqueryui.com/themeroller/">
                    Themes
                  </a>
                </li>
                <li class="jq-development">
                  <a href="https://jqueryui.com/development/">
                    Development
                  </a>
                </li>
                <li class="jq-support">
                  <a href="https://jqueryui.com/support/">
                    Support
                  </a>
                </li>
              </ul>
            </nav>
          </div>
        </div>
      </header>
      <main id="skip" class="flex-column white-box">
        <h2 class="visually-hidden">Search and Top Navigation</h2>
        <div class="flex-row flex-end-center">
          <div id="search"></div>
        </div>
        <nav id="jq-topnav" class="flex-column flex-start-center">
          <a href="/newticket">New Ticket</a>
          <a href="/report">View Tickets</a>
          <a href="/ticketgraph">Ticket Graph</a>
          <a href="/roadmap">Roadmap</a>
          <a href="/timeline">Recent Changes</a>
        </nav>
        <div id="jq-content" class="flex-column">
          

<div class="flex-column" data-pagefind-body="">
  

  <nav class="content-nav">
    <ul class="flex-row">
      
        <li>
          <a href="/ticket/15278/">← Previous Ticket</a>
        
      
      
        </li><li>
          <a href="/ticket/15280/">Next Ticket →</a>
        </li>
      
    </ul>
  </nav>


<div class="ticket-info">
  <div class="flex-row flex-between-start">
    <h2>
      <a href="" class="ticket-number">#15279</a>
      <span class="ticket-status">closed</span>
      <span class="ticket-type">feature</span>
      <span class="ticket-resolution">(wontfix)</span>
    </h2>

    <div class="ticket-dates">
      <p>Opened March 08, 2018 08:28AM UTC</p>
      
        <p>Closed October 25, 2018 01:57PM UTC</p>
      
      
    </div>
  </div>

  <h1 class="ticket-title">Support for private fields and methods within widgets</h1>

  <table class="ticket-properties">
    <tr>
      <th>Reported by:</th>
      <td>
        JakenVeina
      </td>
      <th>Owned by:</th>
      <td></td>
    </tr>
    <tr>
      <th>
        Priority:
      </th>
      <td>
        minor
      </td>
      
        <th class="missing">Milestone:</th>
      
      <td>
        <a href="/milestone/none">none</a>
      </td>
    </tr>
    <tr>
      <th>Component:</th>
      <td>ui.widget</td>
      
        <th>Version:</th>
      
      <td>git (not yet released)</td>
    </tr>
    <tr>
      
        <th class="missing">Keywords:</th>
      
      <td></td>
      
        <th class="missing">Cc:</th>
      
      <td></td>
    </tr>
    <tr>
      <th class="missing">
        Blocked by:
      </th>
      <td></td>
      <th class="missing">
        Blocking:
      </th>
      <td></td>
    </tr>
  </table>
  <div class="ticket-info-bottom">
    <h5 class="ticket-description-title">Description</h5>
    <div class="ticket-description"><p>I've been working lately on a framework of common jQuery widgets, built through the Widget Factory, for use in a larger application, and I've got a lot of widget inheritance going on. I've found myself wishing for a way to have a particular widget define private members that can't accidentally be overridden by another widget, because that implementer didn't realize he defined a field or method with the same name as an existing one on the base widget. In other words, I need a solution for namespace conflicts.</p><p>I've got one that works by adding some additional new functions to $.Widget.prototype, and using a custom wrapper functions for $.widget(), but it's rather cumbersome to use, as it requires widgets to call these additional functions at the beginning of almost every regular function call.</p><p>I took a shot at integrating the "tacked-on" code into the widget component itself, and it's a lot nicer to use. I'm ready to submit a pull request with the code, if there's interest.</p><p>Conceptually, the solution is as follows:</p><p>First, each widget prototype can define a field named "_privates", in the same fashion as the "options" field. When prototypes are merged, however, any "_privates" fields are not simply merged together, but are re-organized into an object structure of the following form:</p><pre class="wiki">
_privates: {
    Namespace1: {
        Widget1: {},
        Widget2: {}
    },
    Namespace2: {
        Widget1: {},
        Widget2: {}
    }
}
</pre><p>Second, the proxy methods that define "_super" and "_superApply" for every method call on the widget instance now also define a "_myPrivates" field, which extracts the appropriate sub-object from the "_privates" object, based on the namespace and name of the prototype that is being proxied.</p><p>Finally, when a new instance of the widget is created, the "_privates" object on the merged prototype is cloned anew for the new instance, similar to the "options" object.</p><p>I also added the step of searching for any functions in the cloned "_privates" object and binding them to the widget instance, so they can access other fields and methods of the widget. Requiring the widget to do this manually seems like pointless boilerplate, but I'm open to discussion.</p><p>Ultimately, you get a system that looks like this:</p><p><a href="https://jsfiddle.net/pz0bk85r/10/" class="ext-link"><span class="icon"></span>https://jsfiddle.net/pz0bk85r/10/</a></p></div>
  </div>
</div>

<details>
  <summary class="ticket-details-summary">Attachments (0)</summary>

  <ul class="ticket-attachments">
    
  </ul>
</details>

<details open="">
  <summary class="ticket-details-summary">Change History (3)</summary>
  
    <div class="ticket-change flex-column" id="comment:1">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed March 08, 2018 08:37AM UTC by <span class="author">JakenVeina</span></span>
        <a class="ticket-change-link" href="#comment:1">comment:1</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>description:</th>
                  <td>
                    
                      <span class="change-field-old">I&#39;ve been working lately on a framework of common jQuery widgets, built through the Widget Factory, for use in a larger application, and I&#39;ve got a lot of widget inheritance going on. I&#39;ve found myself wishing for a way to have a particular widget define private members that can&#39;t accidentally be overridden by another widget, because that implementer didn&#39;t realize he defined a field or method with the same name as an existing one on the base widget. In other words, I need a solution for namespace conflicts.&#92;
&#92;
I&#39;ve got one that works by adding some additional new functions to $.Widget.prototype, and using a custom wrapper functions for $.widget(), but it&#39;s rather cumbersome to use, as it requires widgets to call these additional functions at the beginning of almost every regular function call.&#92;
&#92;
I took a shot at integrating the &quot;tacked-on&quot; code into the widget component itself, and it&#39;s a lot nicer to use. I&#39;m ready to submit a pull request with the code, if there&#39;s interest.&#92;
&#92;
Conceptually, the solution is as follows:&#92;
&#92;
First, each widget prototype can define a field named &quot;_privates&quot;, in the same fashion as the &quot;options&quot; field. When prototypes are merged, however, any &quot;_privates&quot; fields are not simply merged together, but are re-organized into an object structure of the following form:&#92;
&#92;
&#92;
{{{&#92;
_privates: {&#92;
    Namespace1: {&#92;
        Widget1: {},&#92;
        Widget2: {}&#92;
    },&#92;
    Namespace2: {&#92;
        Widget1: {},&#92;
        Widget2: {}&#92;
    }&#92;
}&#92;
}}}&#92;
&#92;
Second, the proxy methods that define &quot;_super&quot; and &quot;_superApply&quot; for every method call on the widget instance now also define a &quot;_myPrivates&quot; field, which extracts the appropriate sub-object from the &quot;_privates&quot; object, based on the namespace and name of the prototype that is being proxied.&#92;
&#92;
Finally, when a new instance of the widget is created, the &quot;_privates&quot; object on the merged prototype is cloned anew for the new instance, similar to the &quot;options&quot; object.&#92;
&#92;
I also added the step of searching for any functions in the cloned &quot;_privates&quot; object and binding them to the widget instance, so they can access other fields and methods of the widget. Requiring the widget to do this manually seems like pointless boilerplate, but I&#39;m open to discussion.&#92;
&#92;
Ultimately, you get a system that looks like this.&#92;
&#92;
{{{&#92;
(function () {&#92;
    let counter = 0;&#92;
&#92;
    $.widget(&quot;Test.WidgetA&quot;, {&#92;
        _create: function () {&#92;
            this._myPrivates.count = ++counter;&#92;
        },&#92;
        _privates: {&#92;
            count: 0,&#92;
            common: &quot;WidgetA&quot;,&#92;
            print: function () {&#92;
                this.element.append(&quot;&lt;div&gt;WidgetA#&quot; + this._myPrivates.count + &quot;&lt;/div&gt;&quot;)&#92;
            },&#92;
        },&#92;
        print: function () {&#92;
            this._myPrivates.print();&#92;
        },&#92;
    });&#92;
})();&#92;
&#92;
(function () {&#92;
    let counter = 0;&#92;
&#92;
    $.widget(&quot;Test.WidgetB&quot;, $.Test.WidgetA, {&#92;
        _create: function () {&#92;
            this._myPrivates.count = ++counter;&#92;
            this._super();&#92;
        },&#92;
        _privates: {&#92;
            count: 0,&#92;
            print: function () {&#92;
                this.element.append(&quot;&lt;div&gt;WidgetB#&quot; + this._myPrivates.count + &quot;&lt;/div&gt;&quot;)&#92;
            },&#92;
        },&#92;
        print: function () {&#92;
            this._super();&#92;
            this._myPrivates.print();&#92;
        },&#92;
    });&#92;
})();&#92;
&#92;
$(document).ready(function () {&#92;
    $(&quot;&lt;h1&gt;&lt;/h1&gt;&quot;)&#92;
        .appendTo($(&quot;body&quot;))&#92;
        .text(&quot;Hello World!&quot;);&#92;
&#92;
    let widget1 = $(&quot;&lt;div&gt;&lt;/div&gt;&quot;)&#92;
        .appendTo($(&quot;body&quot;))&#92;
        .WidgetA()&#92;
        .WidgetA(&quot;instance&quot;);&#92;
&#92;
    let widget2 = $(&quot;&lt;div&gt;&lt;/div&gt;&quot;)&#92;
        .appendTo($(&quot;body&quot;))&#92;
        .WidgetB()&#92;
        .WidgetB(&quot;instance&quot;);&#92;
&#92;
    let widget3 = $(&quot;&lt;div&gt;&lt;/div&gt;&quot;)&#92;
        .appendTo($(&quot;body&quot;))&#92;
        .WidgetA()&#92;
        .WidgetA(&quot;instance&quot;);&#92;
&#92;
    let widget4 = $(&quot;&lt;div&gt;&lt;/div&gt;&quot;)&#92;
        .appendTo($(&quot;body&quot;))&#92;
        .WidgetB()&#92;
        .WidgetB(&quot;instance&quot;);&#92;
&#92;
    widget1.print();&#92;
    widget2.print();&#92;
    widget3.print();&#92;
    widget4.print();&#92;
});&#92;
}}}&#92;
&#92;
... which produces ...&#92;
&#92;
{{{&#92;
WidgetA#1&#92;
WidgetA#2&#92;
WidgetB#1&#92;
WidgetA#3&#92;
WidgetA#4&#92;
WidgetB#2&#92;
}}}&#92;
&#92;
&#92;
</span> → <span class="change-field-new">I&#39;ve been working lately on a framework of common jQuery widgets, built through the Widget Factory, for use in a larger application, and I&#39;ve got a lot of widget inheritance going on. I&#39;ve found myself wishing for a way to have a particular widget define private members that can&#39;t accidentally be overridden by another widget, because that implementer didn&#39;t realize he defined a field or method with the same name as an existing one on the base widget. In other words, I need a solution for namespace conflicts.&#92;
&#92;
I&#39;ve got one that works by adding some additional new functions to $.Widget.prototype, and using a custom wrapper functions for $.widget(), but it&#39;s rather cumbersome to use, as it requires widgets to call these additional functions at the beginning of almost every regular function call.&#92;
&#92;
I took a shot at integrating the &quot;tacked-on&quot; code into the widget component itself, and it&#39;s a lot nicer to use. I&#39;m ready to submit a pull request with the code, if there&#39;s interest.&#92;
&#92;
Conceptually, the solution is as follows:&#92;
&#92;
First, each widget prototype can define a field named &quot;_privates&quot;, in the same fashion as the &quot;options&quot; field. When prototypes are merged, however, any &quot;_privates&quot; fields are not simply merged together, but are re-organized into an object structure of the following form:&#92;
&#92;
&#92;
{{{&#92;
_privates: {&#92;
    Namespace1: {&#92;
        Widget1: {},&#92;
        Widget2: {}&#92;
    },&#92;
    Namespace2: {&#92;
        Widget1: {},&#92;
        Widget2: {}&#92;
    }&#92;
}&#92;
}}}&#92;
&#92;
Second, the proxy methods that define &quot;_super&quot; and &quot;_superApply&quot; for every method call on the widget instance now also define a &quot;_myPrivates&quot; field, which extracts the appropriate sub-object from the &quot;_privates&quot; object, based on the namespace and name of the prototype that is being proxied.&#92;
&#92;
Finally, when a new instance of the widget is created, the &quot;_privates&quot; object on the merged prototype is cloned anew for the new instance, similar to the &quot;options&quot; object.&#92;
&#92;
I also added the step of searching for any functions in the cloned &quot;_privates&quot; object and binding them to the widget instance, so they can access other fields and methods of the widget. Requiring the widget to do this manually seems like pointless boilerplate, but I&#39;m open to discussion.&#92;
&#92;
Ultimately, you get a system that looks like this:&#92;
&#92;
https://jsfiddle.net/pz0bk85r/8/&#92;
</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              
            </div>
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:2">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed March 08, 2018 08:38AM UTC by <span class="author">JakenVeina</span></span>
        <a class="ticket-change-link" href="#comment:2">comment:2</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>description:</th>
                  <td>
                    
                      <span class="change-field-old">I&#39;ve been working lately on a framework of common jQuery widgets, built through the Widget Factory, for use in a larger application, and I&#39;ve got a lot of widget inheritance going on. I&#39;ve found myself wishing for a way to have a particular widget define private members that can&#39;t accidentally be overridden by another widget, because that implementer didn&#39;t realize he defined a field or method with the same name as an existing one on the base widget. In other words, I need a solution for namespace conflicts.&#92;
&#92;
I&#39;ve got one that works by adding some additional new functions to $.Widget.prototype, and using a custom wrapper functions for $.widget(), but it&#39;s rather cumbersome to use, as it requires widgets to call these additional functions at the beginning of almost every regular function call.&#92;
&#92;
I took a shot at integrating the &quot;tacked-on&quot; code into the widget component itself, and it&#39;s a lot nicer to use. I&#39;m ready to submit a pull request with the code, if there&#39;s interest.&#92;
&#92;
Conceptually, the solution is as follows:&#92;
&#92;
First, each widget prototype can define a field named &quot;_privates&quot;, in the same fashion as the &quot;options&quot; field. When prototypes are merged, however, any &quot;_privates&quot; fields are not simply merged together, but are re-organized into an object structure of the following form:&#92;
&#92;
&#92;
{{{&#92;
_privates: {&#92;
    Namespace1: {&#92;
        Widget1: {},&#92;
        Widget2: {}&#92;
    },&#92;
    Namespace2: {&#92;
        Widget1: {},&#92;
        Widget2: {}&#92;
    }&#92;
}&#92;
}}}&#92;
&#92;
Second, the proxy methods that define &quot;_super&quot; and &quot;_superApply&quot; for every method call on the widget instance now also define a &quot;_myPrivates&quot; field, which extracts the appropriate sub-object from the &quot;_privates&quot; object, based on the namespace and name of the prototype that is being proxied.&#92;
&#92;
Finally, when a new instance of the widget is created, the &quot;_privates&quot; object on the merged prototype is cloned anew for the new instance, similar to the &quot;options&quot; object.&#92;
&#92;
I also added the step of searching for any functions in the cloned &quot;_privates&quot; object and binding them to the widget instance, so they can access other fields and methods of the widget. Requiring the widget to do this manually seems like pointless boilerplate, but I&#39;m open to discussion.&#92;
&#92;
Ultimately, you get a system that looks like this:&#92;
&#92;
https://jsfiddle.net/pz0bk85r/8/&#92;
</span> → <span class="change-field-new">I&#39;ve been working lately on a framework of common jQuery widgets, built through the Widget Factory, for use in a larger application, and I&#39;ve got a lot of widget inheritance going on. I&#39;ve found myself wishing for a way to have a particular widget define private members that can&#39;t accidentally be overridden by another widget, because that implementer didn&#39;t realize he defined a field or method with the same name as an existing one on the base widget. In other words, I need a solution for namespace conflicts.&#92;
&#92;
I&#39;ve got one that works by adding some additional new functions to $.Widget.prototype, and using a custom wrapper functions for $.widget(), but it&#39;s rather cumbersome to use, as it requires widgets to call these additional functions at the beginning of almost every regular function call.&#92;
&#92;
I took a shot at integrating the &quot;tacked-on&quot; code into the widget component itself, and it&#39;s a lot nicer to use. I&#39;m ready to submit a pull request with the code, if there&#39;s interest.&#92;
&#92;
Conceptually, the solution is as follows:&#92;
&#92;
First, each widget prototype can define a field named &quot;_privates&quot;, in the same fashion as the &quot;options&quot; field. When prototypes are merged, however, any &quot;_privates&quot; fields are not simply merged together, but are re-organized into an object structure of the following form:&#92;
&#92;
&#92;
{{{&#92;
_privates: {&#92;
    Namespace1: {&#92;
        Widget1: {},&#92;
        Widget2: {}&#92;
    },&#92;
    Namespace2: {&#92;
        Widget1: {},&#92;
        Widget2: {}&#92;
    }&#92;
}&#92;
}}}&#92;
&#92;
Second, the proxy methods that define &quot;_super&quot; and &quot;_superApply&quot; for every method call on the widget instance now also define a &quot;_myPrivates&quot; field, which extracts the appropriate sub-object from the &quot;_privates&quot; object, based on the namespace and name of the prototype that is being proxied.&#92;
&#92;
Finally, when a new instance of the widget is created, the &quot;_privates&quot; object on the merged prototype is cloned anew for the new instance, similar to the &quot;options&quot; object.&#92;
&#92;
I also added the step of searching for any functions in the cloned &quot;_privates&quot; object and binding them to the widget instance, so they can access other fields and methods of the widget. Requiring the widget to do this manually seems like pointless boilerplate, but I&#39;m open to discussion.&#92;
&#92;
Ultimately, you get a system that looks like this:&#92;
&#92;
https://jsfiddle.net/pz0bk85r/10/&#92;
</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              
            </div>
          
        
          
        
      </div>
    </div>
  
    <div class="ticket-change flex-column" id="comment:3">
      <h3 class="flex-row flex-between-start ticket-change-header">
        <span>Changed October 25, 2018 01:57PM UTC by <span class="author">scottgonzalez</span></span>
        <a class="ticket-change-link" href="#comment:3">comment:3</a>
      </h3>

      <div class="ticket-change-content">
        <table class="ticket-changes">
          <tbody>
            
              
            
              
                <tr>
                  <th>resolution:</th>
                  <td>
                    
                      <span class="change-field-new">→ wontfix</span>
                    
                  </td>
                </tr>
              
            
              
                <tr>
                  <th>status:</th>
                  <td>
                    
                      <span class="change-field-old">new</span> → <span class="change-field-new">closed</span>
                    
                  </td>
                </tr>
              
            
          </tbody>
        </table>
        
          
            <div class="ticket-comment-body">
              <p>Use the language as intended.</p>
            </div>
          
        
          
        
          
        
      </div>
    </div>
  
</details>
</div>
        </div>
      </main>
      <footer>
        Copyright &copy; 2024
        <a href="https://openjsf.org">The OpenJS Foundation</a>
      </footer>
    </div>
    <script src="/pagefind/pagefind-ui.js" type="text/javascript"></script>
  </body>
</html>
